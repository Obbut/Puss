// MARK: MeowCore.ejs
<%

eval(include('external/pluralize.js'));

window.acl = argument.accesslevel;

// Selects all classes and structs that are either based on a model or embeddable protocol
window.models = ((types.based["Model"] || []).filter(model => (!model.annotations["skip-meow"]) && model.kind == "class") || []);
window.modelProtocols = ((types.based["Model"] || []).filter(model => (!model.annotations["skip-meow"]) && model.kind == "protocol") || []);
window.embeddables = (types.based["Embeddable"] || []);

// An array containing all serializable types
// Additional types may be added below, in the template itself (supporting implicit serializables)
window.serializables = models.concat(embeddables);
window.serializableTuples = [];

// TODO: FIX generics
window.builtinTypes = ["GridFS.File", "DBRef"];
window.supportedGenerics = ["Reference", "Array<Reference", "Set<Reference", "[Reference"];
window.supportedPrimitives = ["ObjectId", "String", "Int", "Int32", "Bool", "Document", "Double", "Data", "Binary", "Date", "RegularExpression"];
window.numberTypes = ["Int", "Int32", "Double"];
window.supportedRawValues = ["String", "Int", "Int32", "Double"];

Object.assign(window, {
	/**
	Ensures the given type is serializable. If it is not already, it will be added to the serialization code generation queue.

	@param {object} type - The type object (e.g. variable.type) or tuple instance
	*/
	ensureSerializable(type) {
		if (typeof type !== "object") {
			throw "invalid type";
		}

		let typeName = type.unwrappedTypeName || type.name

		if (supportedPrimitives.includes(typeName)) {
			return;
		}

		if (builtinTypes.includes(typeName)) {
			return;
		}

		let isGeneric = false;

		window.supportedGenerics.forEach(generic => {
			if (type.name.startsWith(generic)) {
				isGeneric = true;
			}
		});

		if (isGeneric) { return; }

		if (type.isArray) {
			let arr = type.array;
			ensureSerializable(arr.elementType || arr.elementTypeName);
			return;
		}

		if (type.isTuple) {
			let signature = makeTupleSignature(type);
			if (serializableTuples.find(t => makeTupleSignature(t) == signature)) { return };
			serializableTuples.push(type);
			return;
		}

		// check if it is already in the queue, and if it is, return:
		if (serializables.find(t => t.name == typeName)) { return };
		serializables.push(type);
	},

	/**
	@param {object} tuple - The sourcery tuple object
	@returns {string} The tuple signature
	*/
	makeTupleSignature(tuple) {
		if (tuple.isTuple) {
			// The tuple is secretly a typeName
			tuple = tuple.tuple;
		}

		if (!tuple) {
			throw "invalid tuple";
		}

		return tuple.elements.map(e => (e.typeName.name)).join("And");
	},

	/**
	Generates an error.

	@param {string} text - The text to include in the error
	@return {string} The error
	*/
	meowError(text) {
		return `<# ${text} #>`;
	},

	/**
	Capitalizes the first letter of the given string and returns it.

	@param {string} string - The input string
	@return {string} The capitalized string
	*/
	capitalizeFirstLetter(string) {
		return string.charAt(0).toUpperCase() + string.slice(1);
	},

	/**
	Converts "myNiceString" or "MyNiceString" into "My Nice String"
	*/
	uncamel(str) {
		// http://stackoverflow.com/a/6229124
		return str
			// insert a space between lower & upper
			.replace(/([a-z])([A-Z])/g, '$1 $2')
			// space before last upper in a sequence followed by lower
			.replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1 $2$3')
			// uppercase the first character
			.replace(/^./, function(str){ return str.toUpperCase(); });
	},

	/**
	Converts "My Nice String" or "my nice string" into "my_nice_string"
	*/
	underscoreCase(string) {
		return string.replace(/ /g, "_").toLowerCase();
	},

	/**
	Returns the type string on how to refer to the variable type. Correctly handles arrays and embedded types.
	*/
	variableTypeString(variable, {canBeOptional} = {canBeOptional: true}) {
		if (variable.typeName.isArray) {
			let array = variable.typeName.array;
			return 'Array<' + (array.descend('elementType', 'name') || array.descend('elementTypeName', 'name')) + '>'
		}

		let name;
		if (name = variable.descend('type', 'name')) {
			return variable.isOptional && canBeOptional ? name + '?' : name;
		}

		return canBeOptional ? variable.typeName.name : variable.typeName.unwrappedTypeName;
	}
});

Object.defineProperty(Object.prototype, 'descend', {
	value: function(){
		var keys = arguments;
		var cur = this;
		for(var i=0; i<keys.length; i++){
			var key = keys[i];
			var cur = cur[key];
			if(typeof(cur)=='undefined')
				return cur;
		}
		return cur;
	}
});

%>

// MARK: - General Information
// Supported Primitives: <%- supportedPrimitives.join(', ') %>
// Sourcery Types: <%- types.all.map(t => t.kind + ' ' + t.name).join(', ') %>
